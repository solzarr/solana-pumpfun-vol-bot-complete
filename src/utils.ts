import dotenv from 'dotenv';
import fs from 'fs';
import { struct, bool, u64, Layout, publicKey } from "@coral-xyz/borsh";
import { PublicKey } from "@solana/web3.js";

dotenv.config();

export const retrieveEnvVariable = (variableName: string) => {
    const variable = process.env[variableName] || '';
    if (!variable) {
        console.log(`${variableName} is not set`);
        process.exit(1);
    }
    return variable;
};

export interface Data {
    privateKey: string;
    pubkey: string;
}

export const saveDataToFile = (newData: Data[], filePath: string = "data.json") => {
    try {
        let existingData: Data[] = [];

        // Check if the file exists
        if (fs.existsSync(filePath)) {
            // If the file exists, read its content
            const fileContent = fs.readFileSync(filePath, 'utf-8');
            existingData = JSON.parse(fileContent);
        }

        // Add the new data to the existing array
        if (existingData.length == 0) {
            existingData.push(...newData);

        } else {
            return existingData;
        }

        // Write the updated data back to the file
        fs.writeFileSync(filePath, JSON.stringify(existingData, null, 2));

    } catch (error) {
        try {
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
                console.log(`File ${filePath} deleted and create new file.`);
            }
            fs.writeFileSync(filePath, JSON.stringify(newData, null, 2));
            console.log("File is saved successfully.")
        } catch (error) {
            console.log('Error saving data to JSON file:', error);
        }
    }
};

export function readJson(filename: string = "data.json"): Data[] {
    if (!fs.existsSync(filename)) {
        // If the file does not exist, create an empty array
        fs.writeFileSync(filename, '[]', 'utf-8');
    }
    const data = fs.readFileSync(filename, 'utf-8');

    return JSON.parse(data) as Data[];
}

export function deleteJson(filename: string = "data.json",): void {
    fs.writeFileSync(filename, JSON.stringify([], null, 2));
}

export const sleep = async (ms: number) => {
    await new Promise((resolve) => setTimeout(resolve, ms))
}

export class BondingCurveAccount {
    public discriminator: bigint;
    public virtualTokenReserves: bigint;
    public virtualSolReserves: bigint;
    public realTokenReserves: bigint;
    public realSolReserves: bigint;
    public tokenTotalSupply: bigint;
    public complete: boolean;
    public creator: PublicKey;

    constructor(
        discriminator: bigint,
        virtualTokenReserves: bigint,
        virtualSolReserves: bigint,
        realTokenReserves: bigint,
        realSolReserves: bigint,
        tokenTotalSupply: bigint,
        complete: boolean,
        creator: PublicKey
    ) {
        this.discriminator = discriminator;
        this.virtualTokenReserves = virtualTokenReserves;
        this.virtualSolReserves = virtualSolReserves;
        this.realTokenReserves = realTokenReserves;
        this.realSolReserves = realSolReserves;
        this.tokenTotalSupply = tokenTotalSupply;
        this.complete = complete;
        this.creator = creator;
    }

    getBuyPrice(amount: bigint): bigint {
        if (this.complete) {
            throw new Error("Curve is complete");
        }

        if (amount <= 0n) {
            return 0n;
        }

        // Calculate the product of virtual reserves
        let n = this.virtualSolReserves * this.virtualTokenReserves;

        // Calculate the new virtual sol reserves after the purchase
        let i = this.virtualSolReserves + amount;

        // Calculate the new virtual token reserves after the purchase
        let r = n / i + 1n;

        // Calculate the amount of tokens to be purchased
        let s = this.virtualTokenReserves - r;

        // Return the minimum of the calculated tokens and real token reserves
        return s < this.realTokenReserves ? s : this.realTokenReserves;
    }

    getSellPrice(amount: bigint, feeBasisPoints: bigint): bigint {
        if (this.complete) {
            throw new Error("Curve is complete");
        }

        if (amount <= 0n) {
            return 0n;
        }

        // Calculate the proportional amount of virtual sol reserves to be received
        let n = (amount * this.virtualSolReserves) / (this.virtualTokenReserves + amount);

        // Calculate the fee amount in the same units
        let a = (n * feeBasisPoints) / 10000n;

        // Return the net amount after deducting the fee
        return n - a;
    }

    getMarketCapSOL(): bigint {
        if (this.virtualTokenReserves === 0n) {
            return 0n;
        }

        return (
            (this.tokenTotalSupply * this.virtualSolReserves) /
            this.virtualTokenReserves
        );
    }

    getFinalMarketCapSOL(feeBasisPoints: bigint): bigint {
        let totalSellValue = this.getBuyOutPrice(
            this.realTokenReserves,
            feeBasisPoints
        );
        let totalVirtualValue = this.virtualSolReserves + totalSellValue;
        let totalVirtualTokens = this.virtualTokenReserves - this.realTokenReserves;

        if (totalVirtualTokens === 0n) {
            return 0n;
        }

        return (this.tokenTotalSupply * totalVirtualValue) / totalVirtualTokens;
    }

    getBuyOutPrice(amount: bigint, feeBasisPoints: bigint): bigint {
        let solTokens =
            amount < this.realSolReserves ? this.realSolReserves : amount;
        let totalSellValue =
            (solTokens * this.virtualSolReserves) /
            (this.virtualTokenReserves - solTokens) +
            1n;
        let fee = (totalSellValue * feeBasisPoints) / 10000n;
        return totalSellValue + fee;
    }

    public static fromBuffer(buffer: Buffer): BondingCurveAccount {
        const structure: Layout<BondingCurveAccount> = struct([
            u64("discriminator"),
            u64("virtualTokenReserves"),
            u64("virtualSolReserves"),
            u64("realTokenReserves"),
            u64("realSolReserves"),
            u64("tokenTotalSupply"),
            bool("complete"),
            publicKey("creator"),
        ]);

        let value = structure.decode(buffer);
        return new BondingCurveAccount(
            BigInt(value.discriminator),
            BigInt(value.virtualTokenReserves),
            BigInt(value.virtualSolReserves),
            BigInt(value.realTokenReserves),
            BigInt(value.realSolReserves),
            BigInt(value.tokenTotalSupply),
            value.complete,
            value.creator
        );
    }
}


